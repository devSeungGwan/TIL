# Micro Service Architecture

애플리케이션을 느슨히 결합된 서비스의 모임을 구조화하는 서비스 지향 아키텍처(SOA, Service Oriented Architecture) 스타일의 일종인 소프트웨어 개발 기법이다. 애플리케이션을 특화된 기능별로 나누게 되면 자연스럽게 애플리케이션의 추상화가 가능해진다. 기능 별로 인터페이스를 구성하여 다른 기능들과 통신할 수 있도록 구성한다. 이를 통해 언어가 다른 어플리케이션이라도 통신이 가능하며, 유연하게 기능을 변경할 수 있다.

![](https://miro.medium.com/max/700/1*r3qD5OBLgaizuiCImUJxYQ.png) 



> Micro Service Architecture 예시

비지니스 워크플로를 얼마나 잘 나누어 시스템을 구성했는 지가 중요하다. 각각의 서비스들은 결합도가 낮게 분리되어 있고, 자신의 역할에 맞게 동작하기 때문이다. 이런 서비스들이 서로에게 영향을 미치지 않기 위해선, 분산 데이터베이스를 두어 운영해야 한다. 각 서비스 별로 데이터베이스를 두어 상호작용을 하고 다른 DB에는 영향을 미치지 못하도록 해야 한다.

 ![Image for post](https://miro.medium.com/max/756/1*iZfTRFER98BLoZo8dmU_1g.png)

>  MSA 의 장점 중에 하나인 확장성을 나타낸다.

* X축
  * 마이크로 서비스를 복제하여 늘리는 개수

* Y축
  * 마이크로 서비스를 기능 별로 분리하는 것

* Z축
  * 데이터 분산 저장

어플리케이션의 확장이 용이하기 때문에, 개발 생산성 및 속도가 증가하며, 최신기술로의 교체가 용이하다.

![](https://miro.medium.com/max/700/1*oMcZgGCK4DS1INQDN2kH-A.png)

> 각 서비스 별로 대응하는 DB를 설계해야 한다.

MSA에서 각각의 서비스는 오직 자신과 상호작용하는 DB를 갖기 때문에 서비스의 성격에 따라 DB를 선택할 수 있다. 하지만 서비스가 동작하면서 여러 데이터에 영향을 미치기 때문에 각 서비스 별로 중복되는 데이터가 발생한다. 또한 한 쪽에서 업데이트되었는데 다른 쪽에서는 업데이트가 되지 않을 수 있다. 이러한 중복과 정합성 문제가 있지만 결합도를 낮추기 위해서 각각의 DB를 사용한다.

## 철학

* 단일 책임 원칙(SRP, Single Responsibility Prienciple)을 중심으로 한다. 즉 큰 문제를 작은 문제로 분해해서 처리하고, 각 기능들이 다른 기능들에게 영향을 미치지 않게 설계한다. 
* 서비스의 크기가 작다
  * 하나의 기능을 수행하는데 섬세하다.
* 조직 문화는 테스트 및 전개의 자동화를 받아드려야 한다.
  * 이를 통해 관리 및 운용상의 부담을 완화하며, 다른 개발팀들의 코드의 전개 가능한 단위를 독립적으로 작업할 수 있게 한다.
* 문화와 디자인 철학은 안티프레질 시스템(antifragile system)과 비슷하게 실패와 고장을 받아들여야 한다.
* 각 서비스를 유연하고 회복력있게 구성할 수 있으며 최소한이고 완전하다.

## 특징

* 배포 및 운영이 용이하다.

* 서비스의 교체가 쉽다.

* 서비스는 기능별로 분류된다.

* 서비스는 최적의 조건에 부합하는 바에 따라 각기 다른 프로그래밍 언어, 데이터베이스, 하드웨어, 소프트웨어 환경을 사용하여 구현할 수 있다.

* 서비스들은 규모가 작고, 메시지 전달이 가능하며 컨텍스트별로 묶이며 자율적으로 개발되며 독립적으로 전개할 수 있고 분산적이며, 자동화된 프로세스들로 출시된다.

* 모듈성이 있는 구조를 강제한다.

* 자기 자신을 지속적 배포 소프트웨어 개발 프로세스에 위치시킨다.  애플리케이션의 사소한 부분의 변경은 하나 이상의 적은 수의 서비스 빌드, 재전개만을 필요로 한다.

* 섬세한(fine-grained) 인터페이스, 비지니스 주도의 개발, 클라우드 애플리케이션 등에 사용될 수 있다.

## 단점

* 작은 서비스 단위로 개발하기 때문에, 배포가 어렵다.

* 서비스간 통신 방법(인터페이스)을 구축해야 한다.

* 데이터 중복이 발생하고 정합성을 보장하기 어렵다.

* 테스트가 복잡하고 어렵다.

#  Monilithic Architecture

모듈별로 개발을 하고, 개발이 완료된 어플리케이션을 하나의 결과물로 패키징하여 배포하는 형태를 말한다. 

![](https://miro.medium.com/max/700/1*OQ6YdrPe2Vb8UvjgxbVI6A.png)

## 장점

하나의 어플리케이션에 대한 개발, 빌드, 배포, 테스트를 진행하기 때문에 간단하다.

## 단점

* CI(Continious Integration)/CD(Continious Delivery)가 어렵다.

* 모든 모듈의 하나의 프로세스에서 동작하기 때문에 하나의 모듈이 수정되어, 서버를 내렸다 올리게 될 경우 다른 모듈도 작동이 불가능한 상태가 된다.

* 확장 이슈 및 광범위한 운영 로드맵 등

# Reference

마이크로서비스([Link](https://ko.wikipedia.org/wiki/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4))

Microservice Architecture란?([Link](https://medium.com/webeveloper/microservice-architecture%EB%9E%80-ca9825087050))

Introduction to Microservices([Link](https://www.nginx.com/blog/introduction-to-microservices/))

마이크로서비스 아키텍처([Link](http://guruble.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4microservice-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AD%A3%EC%9D%B4-%EC%A4%91%ED%97%8C%EB%94%94/))

